///////////////////////////////////////////////////////////////////////
////                        IMPORTS                                ////
///////////////////////////////////////////////////////////////////////

const dotenv = require('dotenv');
const fs = require('fs');
const express = require('express');
const cors = require('cors');
var glob = require("glob");
var app = express();
var readline = require('readline');
var HTMLParser = require('node-html-parser');
var req_type = 'http';

////////////////////////////////////////////////////////////////////////
////                        CONFIG                                  ////    
////////////////////////////////////////////////////////////////////////

//To use cors
app.use(cors());
const execSync = require('child_process').execSync;

//to use environment variables from .env file
dotenv.config();
console.log(process.env.USER_SSH);
var SCRIPT_ARGS = `userdb=${process.env.USER_LIST},passdb=${process.env.SHORT_P}`
console.log(SCRIPT_ARGS);

//to use MQTT package import
var mqtt = require('mqtt');

// MQTT CONNECTION SETUP
var client = mqtt.connect('mqtt://broker.hivemq.com:1883');

client.on('connect', function () {
    console.log('Connected');
    client.subscribe('pentest/start');
    client.subscribe('test/file/node');

    console.log('Hello from the other side');
});

//NMAP FILES
var SCRIPT_SYN = 'script-syn';
var UDP = 'udp';
var SYN = 'syn';
var targetIP = '192.168.1';
var start = 1, end = 10;
var phases = '';
var ips = [];
var flag_ = 0

//FINAL REPORT JSON TEMPLATE FOR ONE DEVICE
var report_JSON = {
    Device_info: {},
    CVEs: [],
    Webservers: [],
    Missing_headers: [],
    Credentials_found: []
}

//FINAL REPORT JSON TEMPLATE FOR ALL DEVICES
var device_Reports = {
    devices: []
}

//MQTT SETTING
client.on('message', function (topic, message) {
    if (topic == 'test/file/node') {
        console.log('Received File..');
        var msg = JSON.parse(message);
        console.log(msg.filename);
        let buff = new Buffer(msg.data, 'base64');
        console.log(buff.toString('ascii'));
        fs.writeFileSync('result_meta_modul.txt', buff);
        console.log('Result written out');
    } else {
        client.publish('pentest/updates', 'Launched Security Tests, this may take from several minutes to a few hours. You will be notified once the tests have ended.');
        req_type = 'mqtt';
        console.log(message.toString());
        console.log(topic);
        var mqttReq = JSON.parse(message.toString());
        console.log(mqttReq.ip[mqttReq.ip.length - 1]);
        start = mqttReq.ip[0], end = mqttReq.ip[mqttReq.ip.length - 1];
        ips = mqttReq.ip;
        targetIP = mqttReq.domain;
        phases = 'ivd';
        setTimeout(() => {
            main();
        }, 3000)

    }


});

/////////////////////////////////////////////////////////////////////////
////                        APP LOGIC                                ////
/////////////////////////////////////////////////////////////////////////

var filepaths = [];

// MAIN
async function main(res) {
    console.log(req_type);
    filepaths = [];
    device_Reports.devices = [];
    var host = '';
    console.log('In Main');
    var start_loop, end_loop;

    //check the type of request, http or mqtt
    if(req_type == 'mqtt'){
        start_loop = 0, end_loop = ips.length - 1;
    } else if(req_type == 'http'){
        start_loop = Number(start), end_loop = Number(end);
    }
    console.log(start_loop + ' ' + end_loop);
    //loop through the number of devices given in the request
    for (var i = start_loop; i <= end_loop; i++){

        //create filepath and host name and construct the device IP address from the given request
        if(req_type == 'mqtt'){
            host = targetIP + '.' + ips[i];
        } else if(req_type == 'http') {
            host = targetIP + '.' + i;
        }
        console.log(host);
        var dir = new Date().toISOString() + '_Report';
        var filepath = dir + '/' + host; 

        //push each device into the filepaths array for later use
        filepaths.push(filepath);

        //INFORMATION GATHERING FUNCTION
        function informationGathering() {
            console.log('Starting Information Gathering...');
            // execSync(`openssl enc -d -aes-256-cbc -in oIG.sh -out u_oIG.sh -k ayeshwashere`);
            execSync(`mkdir ${filepath}/IG; mkdir ${filepath}/IG/NMAP`);
            const resu = execSync(`bash IG.sh ${dir} ${host} ${filepath} ${process.env.METASPLOIT_SCAN_SCRIPT}`);
            console.log('Done with Information Gathering, Check local directory to view results.');
            // execSync(`rm u_oIG.sh`);
        }

        //VULNERABILITY ASSESSMENT FUNCTION
        function vulnerabilityAssessment() {
            console.log('Starting Vulnerability Assessment...');
            // execSync(`openssl enc -d -aes-256-cbc -in oVA.sh -out u_oVA.sh -k ayeshwashere`);
            execSync(`mkdir -p "${filepath}/VA"`);
            //parse nmap output in search of CVE

            execSync(`xmllint --xpath "//table[elem[text()='VULNERABLE' and @key='state']]/@key" "${filepath}/IG/NMAP/cve.xml" 2> /dev/null | tr " " "\n" | cut -f2 -s -d'"' | awk -F "CVE-" '{printf "search CVE:" ; print $2}' > "${filepath}/IG/NMAP/CVE.txt"`);
            execSync(`xmllint --xpath "//table[elem[text()='LIKELY VULNERABLE' and @key='state']]/@key" "${filepath}/IG/NMAP/cve.xml" 2> /dev/null | tr " " "\n" | cut -f2 -s -d'"' | awk -F "CVE-" '{printf "search CVE:" ; print $2}' > "${filepath}/IG/NMAP/CVE.txt"`);
            execSync(`xmllint --xpath "//table[elem[text()='VULNERABLE' and @key='state']]/@key" "${filepath}/IG/NMAP/script-syn.xml" 2> /dev/null | tr " " "\n" | cut -f2 -s -d'"' | awk -F "CVE-" '{printf "search CVE:" ; print $2}' >> "${filepath}/IG/NMAP/CVE.txt"`);
            execSync(`xmllint --xpath "//table[elem[text()='LIKELY VULNERABLE' and @key='state']]/@key" "${filepath}/IG/NMAP/script-syn.xml" 2> /dev/null | tr " " "\n" | cut -f2 -s -d'"' | awk -F "CVE-" '{printf "search CVE:" ; print $2}' >> "${filepath}/IG/NMAP/CVE.txt"`);
            execSync(`xmllint --xpath "//table[elem[text()='VULNERABLE' and @key='state']]/@key" "${filepath}/IG/NMAP/${UDP}.xml" 2> /dev/null | tr " " "\n" | cut -f2 -s -d'"' | awk -F "CVE-" '{printf "search CVE:" ; print $2}' >> "${filepath}/IG/NMAP/CVE.txt"`);
            execSync(`xmllint --xpath "//table[elem[text()='LIKELY VULNERABLE' and @key='state']]/@key" "${filepath}/IG/NMAP/${UDP}.xml" 2> /dev/null | tr " " "\n" | cut -f2 -s -d'"' | awk -F "CVE-" '{printf "search CVE:" ; print $2}' >> "${filepath}/IG/NMAP/CVE.txt"`);

            //create new dir for exploits
            execSync(`mkdir -p "${filepath}/VA/KNOWN_EXPLOITS"`);
            execSync(`bash VA.sh ${dir} ${host} ${filepath} ${process.env.HTTP_WORDLIST} ${process.env.HTTP_EXTENSIONS_FILE}`);
            console.log('Done with Vulnerability Assessment, Check directory for results.');
            // execSync('rm u_oVA.sh');
        }

        //DICTIONARY ATTACKS FUNCTION
        function dictionaryAttacks() {
            console.log('Starting Dictionary Attacks...');
            // execSync(`openssl enc -d -aes-256-cbc -in oDA.sh -out u_oDA.sh -k ayeshwashere`);
            execSync(`mkdir -p "${filepath}/DA/PASSWORD"`);
            execSync(`mkdir -p "${filepath}/DA/EVIDENCE"`);
            console.log(filepath);
            var re = execSync(`bash DA.sh ${dir} ${host} ${filepath} ${process.env.USER_SSH} ${process.env.USER_RDP} ${process.env.USER_SMB} ${process.env.USER_LIST} ${process.env.PASS_HYDRA} ${process.env.PASS_SSH} ${process.env.PASS_RDP} ${process.env.PASS_SMB} ${process.env.SHORT_P} ${process.env.LONG_P}`);
            console.log('Done with Dictionary Attacks, Check directory for results.');
            // execSync('rm u_oDA.sh');
        }

        execSync(`mkdir ${dir}; mkdir ${filepath}`);

        //Check which phases were included in request and start the tests accrodingly
        if (phases.includes('i') && phases.includes('v') && phases.includes('d')) {
            console.log('All phases included');
            informationGathering();
            vulnerabilityAssessment();
            dictionaryAttacks();
        }
        else {
            if (phases.includes('i')) {
                informationGathering();

            }

            if (phases.includes('v')) {
                if (phases.includes('i') == false) {
                    console.log('Information gathering was not included, but is needed..Conducting it now!');
                    informationGathering();

                }
                vulnerabilityAssessment();
            }

            if (phases.includes('d')) {
                if (phases.includes('i') == false && phases.includes('v') == false) {
                    console.log('Information Gathering was not included but is needed.. Conducting it now!');
                    informationGathering();
                }
                if (phases.includes('v') == false) {
                    console.log('Vulnerability Assessment was not included but is needed.. Conducting it now!');
                    vulnerabilityAssessment();
                }
                dictionaryAttacks();
            }
        }
    }

    //generate report for each device in the filepaths array
    for(var l = 0; l< filepaths.length; l++){
        await generateReport(filepaths[l],res);
    }
}

//FUNCTION TO GENERATE REPORT
function generateReport(filepath,response) {
    console.log('Inside Report Generation');
    var flag_loop = false;

    //CVE report
    if (fs.existsSync(`${filepath}/VA/KNOWN_EXPLOITS/meta_module.txt`)) {
        console.log('This exists');
        var res = execSync(`awk -f awkscript_CVE ${filepath}/VA/KNOWN_EXPLOITS/meta_module.txt`);
        var res_arr = res.toString().split('\n');
        var cve_code = '';
        var cve_j = 0;
        for (var i = 0; i < res_arr.length - 1; i++) {
            if (res_arr[i].substring(0, 4) == 'CVE:') {
                cve_code = res_arr[i];
            } else {
                var actual_res_arr = res_arr[i].split(/\s{2,}/g);
                report_JSON.CVEs[cve_j] = {
                    CVE_code: cve_code,
                    CVE_name: actual_res_arr[2],
                    CVE_discolosure_date: actual_res_arr[3],
                    CVE_rank: actual_res_arr[4],
                    CVE_description: actual_res_arr[6]
                }
                cve_j++;
            }
        }
        console.log(res_arr);
        console.log(report_JSON);
    } else {
        report_JSON.CVEs = ['No CVEs found on this device!'];
        console.log('CVE done');
    }

    //Hidden content report
    var webserver_j = 0;
    console.log(filepath);
    glob(`${filepath}/VA/dirb_*.txt`, {}, function (er, files) {
        console.log('Inside first glob: '+ filepath);
        if(er){
            console.log('Err in Webservers');
            return;
        }
        if (files.length > 0) {
            console.log('Found Dirb Files');
            console.log(files);
            for (var i = 0; i < files.length; i++) {
                var webserverPort = files[i].split('/')[3].split('_')[1].split('.')[0];
                console.log(webserverPort);
                var res = execSync('awk -f awkscript_Dirb ' + files[i]);
                var res_arr = res.toString().split('\n');
                console.log(res_arr);
                var hidden_content = [];
                for (var j = 0; j < res_arr.length; j++) {
                    if (res_arr[j].length > 0) {
                        hidden_content.push(res_arr[j].split('/')[3]);
                        console.log(hidden_content);
                    }
                }
                report_JSON.Webservers[webserver_j] = {
                    port: webserverPort,
                    hidden_content: hidden_content
                }
                webserver_j++;
                console.log(JSON.stringify(report_JSON));
            }
        } else {
            report_JSON.Webservers = ['No Webservers found running on this host!'];
            console.log('No Webservers');
        }

    });

    //Missing headers report
    let promises = [];
    glob(`${filepath}/VA/nikto_*.html`, {}, function (er, files) {
        console.log('Inside second glob: ' + filepath);
        if(er){
            console.log('Err in Nikto');
            report_JSON.Missing_headers = ['No Missing headers found!'];
            return;
        }
        if (files.length > 0) {
            console.log('Found Nikto Files');
            console.log(files);
            var file_counter = 0;
            for (var i = 0; i < files.length; i++) {
                var headerIndex = 0;
                var headers = [];
                var rl = readline.createInterface({
                    input: fs.createReadStream(files[i]),
                    output: process.stdout,
                    terminal: false
                });
                var next = 0, uri = '', http_method = '', description = '', target_IP = '', target_hostname = '', target_port = '', site_link_name = '', site_link_ip = '';
                var promise = new Promise(function (resolve, reject) {
                    rl.on('line', function (line) {
                        if (next == 0 && line.includes('URI')) {
                            next = 1;
                        } else if (next == 1) {
                            var root = HTMLParser.parse(line);
                            uri = root.text;
                            next = 0;
                        } else if (next == 0 && line.includes('HTTP Method')) {
                            next = 2;
                        } else if (next == 2) {
                            var root = HTMLParser.parse(line);
                            http_method = root.text;
                            next = 0;
                        } else if (next == 0 && line.includes('Description')) {
                            next = 3;

                        } else if (next == 3) {
                            var root = HTMLParser.parse(line);
                            description = root.text;
                            headers[headerIndex] = {
                                uri: uri,
                                http_method: http_method,
                                description: description
                            }
                            headerIndex++;
                            next = 0;
                        } else if (next == 0 && line.includes('Target IP')) {
                            next = 4;
                        } else if (next == 4) {
                            var root = HTMLParser.parse(line);
                            target_IP = root.text;
                            next = 0;
                        } else if (next == 0 && line.includes('Target hostname')) {
                            next = 5;
                        } else if (next == 5) {
                            var root = HTMLParser.parse(line);
                            target_hostname = root.text;
                            next = 0;
                        } else if (next == 0 && line.includes('Target Port')) {
                            next = 6;
                        } else if (next == 6) {
                            var root = HTMLParser.parse(line);
                            target_port = root.text;
                            next = 0;
                        } else if (next == 0 && line.includes('Site Link (Name)')) {
                            next = 7;
                        } else if (next == 7) {
                            var root = HTMLParser.parse(line);
                            site_link_name = root.text;
                            next = 0;
                        } else if (next == 0 && line.includes('Site Link (IP)')) {
                            next = 8;
                        } else if (next == 8) {
                            var root = HTMLParser.parse(line);
                            site_link_ip = root.text;
                            next = 0;
                        } else if (line.includes('Scan Summary')) {
                            report_JSON.Missing_headers[file_counter] = {
                                port: target_port,
                                target_IP: target_IP,
                                target_hostname: target_hostname,
                                site_link_name: site_link_name,
                                site_link_ip: site_link_ip,
                                headers: headers
                            };
                            file_counter++;
                            headers = [];
                            headerIndex = 0;
                            resolve('Done');
                        }
                    });
                });
                promises.push(promise);

            }
            Promise.all(promises).then((values) => {
                console.log(report_JSON);
                infoReport();
            });
        } else {
            report_JSON.Missing_headers = ['No Missing headers found!'];
            infoReport();
        }

    });

    //Information Gathering report
    function infoReport() {
        console.log('Inside infoReport: ' + `${filepath}/IG/NMAP/syn.nmap`);
        var open_ports = [], open_ports_udp = [];
        var res = execSync('awk -f awkscript_nmap ' + `${filepath}/IG/NMAP/syn.nmap`);
        console.log(res);
        var res_arr = res.toString().split('\n');
        console.log(res_arr);
        var mac_address = 'No MAC Address found!', device_type = 'Device type not identified!', os_cpe = 'No OS CPE found!', os_details = 'OS Details not found!', fingerprint = 'No fingerprint found!';
        for (var i = 0; i < res_arr.length - 1; i++) {
            if (res_arr[i].includes('MAC Address:')) {
                mac_address = res_arr[i].substring(13);
                console.log(mac_address);
            } else if (res_arr[i].includes('Device type:')) {
                device_type = res_arr[i].substring(13);
                console.log(device_type);
            } else if (res_arr[i].includes('OS CPE:')) {
                os_cpe = res_arr[i].substring(8);
                console.log(os_cpe);
            } else if (res_arr[i].includes('OS details:')) {
                os_details = res_arr[i].substring(12);
                console.log(os_details);
            } else if (res_arr[i].includes('/tcp')) {
                var port_details = res_arr[i].split(' + ');
                console.log(port_details);
                var port = port_details[0], state = port_details[1], service = port_details[2], reason = port_details[3], version = 'Not determined!'
                if (port_details[4] != '') {
                    version = port_details[4];
                }
                open_ports.push({
                    port: port,
                    state: state,
                    service: service,
                    reason: reason,
                    version: version
                });
            }

        }
        var res2 = execSync('awk -f awkscript_nmap ' + `${filepath}/IG/NMAP/udp.nmap`);
        console.log(res2);
        var res_arr2 = res2.toString().split('\n');
        console.log(res_arr2);
        for (var i = 0; i < res_arr2.length - 1; i++) {
           if (res_arr2[i].includes('/udp')) {
                var port_details = res_arr2[i].split(' + ');
                console.log(port_details);
                var port = port_details[0], state = port_details[1], service = port_details[2], reason = port_details[3], version = 'Not determined!'
                if (port_details[4] != '') {
                    version = port_details[4];
                }
                open_ports_udp.push({
                    port: port,
                    state: state,
                    service: service,
                    reason: reason,
                    version: version
                });
            }
        }
        var fingerprint_index = res_arr.findIndex(el => el.includes('OS:'));
        console.log(fingerprint_index);
        if (fingerprint_index >= 0) {
            var fingerprint_arr = res_arr.slice(fingerprint_index);
            fingerprint = fingerprint_arr.join('').replace(/OS:/g, '');
            console.log(fingerprint);
        }
        report_JSON.Device_info = {
            mac_address: mac_address,
            device_type: device_type,
            os_cpe: os_cpe,
            os_details: os_details,
            os_fingerprint_tcp: fingerprint,
            ports_detected: {
                TCP: open_ports,
                UDP: open_ports_udp
            }
        }
        dictionaryAttackReport();

    }

    //Dictionary Attack Report
    function dictionaryAttackReport() {
        glob(`${filepath}/DA/PASSWORD/cred_*`, {}, function (er, files) {
            if (er) {
                report_JSON.Credentials_found = ['No Credentials found!'];
                return;
            }
            if (files.length > 0) {
                console.log(files);
                for (var r = 0; r < files.length; r++) {
                    var res = execSync('awk -f awkscript_DA ' + files[r]);
                    var credentials = [], port = '', service = '', host = '', login = '', password = '';
                    var res_arr = res.toString().split('\n');
                    console.log(res_arr);
                    for (var j = 0; j < res_arr.length - 1; j++) {
                        var split_arr = res_arr[j].split(' ');
                        host = split_arr[1], login = split_arr[2], password = split_arr[3];
                        var port_service_split = split_arr[0].replace(/[\[,\]]/g, '+').split('+');
                        port = port_service_split[1], service = port_service_split[3];
                        var credential = {
                            port: port,
                            service: service,
                            host: host,
                            login: login,
                            password: password
                        }
                        credentials.push(credential);
                    }
                }
                report_JSON.Credentials_found = credentials;
                fs.writeFileSync('report.json', JSON.stringify(report_JSON));
                device_Reports.devices.push(report_JSON);
                if(l == filepaths.length - 1){
                    client.publish('pentest/complete', JSON.stringify(device_Reports));
                    flag_ = 1;
                    if(req_type != 'http'){
                        filepaths = [];
                        device_Reports.devices = [];
                    } else {
                        response.send(JSON.stringify(device_Reports));
                    }
                }
                
            } else {
                report_JSON.Credentials_found = ['No credentials found'];
                fs.writeFileSync('report.json', JSON.stringify(report_JSON));
                device_Reports.devices.push(report_JSON);

                if(filepath == filepaths[filepaths.length - 1]){
                    client.publish('pentest/complete', JSON.stringify(device_Reports));
                    flag_ = 1;
                    if(req_type != 'http'){
                        filepaths = [];
                        device_Reports.devices = [];
                    } else {
                        response.send(JSON.stringify(device_Reports));
                    }
                }
                console.log(device_Reports);
            }
        });

    }
}

//GET route
app.get('/starttest/:target/:start/:end/:phases', (req, res) => {
    req_type = 'http';
    console.log('Received a request...');
    console.log('Target IP:' + req.params.target);
    console.log('Phases:' + req.params.phases);
    targetIP = req.params.target;
    start = req.params.start, end = req.params.end;
    ips.push(req.params.start);
    ips.push(req.params.end);
    phases = req.params.phases;
    main(res);
    console.log(JSON.stringify(device_Reports));

});

//START SERVER
app.listen(3005, () => {
    console.log('Server started...');
});


